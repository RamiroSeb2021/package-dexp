% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metodo_Harris_Hurvitz_Mood.R
\name{k_tabla_mc}
\alias{k_tabla_mc}
\title{Calcular el valor \(k = a/s_1\) para tablas de potencia (simulación Monte Carlo)}
\usage{
k_tabla_mc(n, m, beta = 0.8, alpha = 0.05, B = 2e+06, seed = 1)
}
\arguments{
\item{n}{Integer. Grados de libertad de la desviación estándar muestral nueva \(s_2\).}

\item{m}{Integer. Grados de libertad de la desviación estándar preliminar \(s_1\).}

\item{beta}{Numeric. Potencia deseada de la prueba (\(1-\) error tipo II), por defecto 0.80.}

\item{alpha}{Numeric. Nivel de significancia de la prueba (cola superior), por defecto 0.05.}

\item{B}{Integer. Número de réplicas de Monte Carlo para estimar potencias, por defecto 2e6.}

\item{seed}{Integer. Semilla para reproducibilidad de la simulación, por defecto 1.}

\item{tol}{Numeric. Tolerancia de la búsqueda de raíces con \code{uniroot()}, por defecto 0.001.}
}
\value{
Numeric. Estimación de \(k = a/s_1\) que logra potencia \code{beta} al nivel \code{alpha}.
}
\description{
Esta función estima el valor \(k = a/s_1\) necesario para que una prueba de Student
unitaria (una sola cola), con \(\alpha\) nivel de significancia y \(\beta\) potencia,
rechace la hipótesis nula \(\mu=0\) cuando la media verdadera es \(\mu=a\).
Utiliza simulación Monte Carlo de las distribuciones muestrales de \(s_1\) y \(s_2\).
}
\details{
\enumerate{
\item Se simulan \code{B} valores de
\(\,s_1 \sim \sqrt{\chi^2_m / m}\) y \(\,s_2 \sim \sqrt{\chi^2_n / n}\).
\item Para cada \(k\) candidato, se fija \(a = k\,s_1\), se simulan \(\bar X \sim N(a,\,1/(n+1))\)
y se computa la estadística \(t = \sqrt{n+1}\,\bar X / s_2\).
\item La potencia empírica es la proporción de réplicas donde \(t > t_{1-\alpha}(n)\).
\item \code{uniroot()} busca el \(k\) tal que la potencia simulada sea igual a \code{beta}.
}
}
\examples{
# Generar la tabla completa de k para beta = 0.95, alpha = 0.05
n_vals <- 1:10
m_vals <- c(1:6, 8, 12, 16, 24, 32)

# Inicializar matriz vacía con nombres de fila/columna
k_matrix <- matrix(NA,
                   nrow = length(n_vals),
                   ncol = length(m_vals),
                   dimnames = list(paste0("n=", n_vals),
                                   paste0("m=", m_vals)))

# Llenar matriz con k calculados
for (i in seq_along(n_vals)) {
  for (j in seq_along(m_vals)) {
    n <- n_vals[i]
    m <- m_vals[j]
    k_matrix[i, j] <- k_tabla_mc(n, m,
                                  beta = 0.95,
                                  alpha = 0.05,
                                  B = 5e5,   # ajustar B si se desea más precisión
                                  tol = 1e-3)
  }
}

# Convertir a data.frame para mostrar
k_df <- as.data.frame(k_matrix, row.names = NULL)
k_df <- cbind(n = n_vals, k_df)
print(k_df, digits = 4)
View(round(k_df[-1], 3))

}
